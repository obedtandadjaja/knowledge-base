# Golang

Golang is a fast, compiled, garbage-collected, concurrent systems programming language. Golang was created as a future-proof language to meet the challenges of the present and anticipate challenges of the future.

Advantages:
- Compiles large projects within a few seconds
- Open source by nature so defects will be detected and eliminated faster
- Fast since it has simple structure and syntax. It is devoid of classes and type inheritance. The language is based on functions, so it is simple and fast to learn. It’s compiled so it provides faster feedback, shorter time to market, and saves time and money.  It’s simple, so it is more maintainable, and development is faster and cheaper.
- Concurrent in nature with the help of goroutines, channels, and garbage collection
- Cross-platform
- Statically typed so developers have to be more accurate and attentive, so the code is neater and safer

Disadvantages:
- Less flexible copared to other dynamically typed languages
- Lack of 3rd party modules
- Differs a lot from C-based languages
- Has no generics (generics allow writing code which can be reusable - it saves time and effort in some cases)

## Commands

### go build

- Compiles packages and dependencies
- Go build ignores files whose names start with `_` or `.`
- By default the executable will be generated in the same folder. If you want the file to be generated in `$GOPATH/bin` then use `go install` instead
- `go build` will compile all the files in the folder, if you just want to compile one file then use `go build <file_path>`

### go clean

- Cleans files that are generated by compilers
- Do this before pushing a commit to Github

### go fmt

- Enforces go code formatting to the project. It will rewrite the source files after formatting code

### go get

- Fetches remote packages. Currently only supports BitBucket, Github, Google Code, and Launchpad
- Does the following actions: downloads the source code, then executes `go install`

### go install

- Compiles all packages and generates files, then moves them to `$GOPATH/pkg` or `$GOPATH/bin`

### go test

- Loads all files whose name include `*_test.go` and generates test files, then prints information about the test results
- Tests all your test files by default

### go fix

- Upgrades from an older version to newer version of golang

### go list

- Lists all installed packages

### go run

- Compiles temporary files and run the application

## Basic Knowledge

25 keywords:
```
break    default      func    interface    select
case     defer        go      map          struct
chan     else         goto    package      switch
const    fallthrough  if      range        type
continue for          import  return       var
```

Go programs are composed by `package`. `package main` tells us that this package will be compiled to a program instead of package files whose extensions are `.a`.

Every executable program has one and only one `main` package, and you need an entry function called `main` without any arguments or return values in the `main` package.

The way to think about packages in Go is `modularity` (break up program into many modules) and `reusability` (every module can be reused by many programs).

Each go file is in some package, and that package should be a distinct folder in the GOPATH, but main is a special package which doesn't require a `main` folder. 

Conclusion: Go uses `package` (like modules in Python) to organize programs. The function `main.main()` is the entry point of any program. Go standardizes language and most of the programming methodology (gofmt).

## Naming Convention

- Any variable that beings with a capital letter means it will be exported, private otherwise.
- The same rule applies for functions and constants, no `public` or `private` keyword exists in Go.

## Foundation

### Define variables

The keyword `var` is the basic form to define variables, notice that Go puts the variable type `after` the name.

```golang
var variableName type
var var1, var2, var3 type
var myName string = "Obed"
var sibling1, sibling2 string = "Abel", "Olivia"
var sibling1, sibling2 = "Abel", "Olivia"
```

We can also use `:=` to replace `var` and `type` combination, this is called a `short assignment`. It has one limitation: it can only be used inside of a function. You will get compile error when it is called outside of function block. Therefore, `var` is used to define global variables

```golang
myName := "Obed"
```

`_` (blank) is a special variable name. Any value that is given to it will be ignored

```golang
_, b := 34, 35
```

### Constants

Values that are determined during compile time and cannot be changed during runtime. In Go, you can use number, boolean, enum, or string as constant types

```golang
const str = "a string"
const str string = "a string"

const bool = true
const num = 1000
const pi = 3.14
```

### Numerical types

```
rune   int8   int16   int32   int64
byte   uint8  uint16  uint32  uint64
float32  float64
```

`rune` is alias of `int32` and `byte` is alias of `uint8`.

You cannot assign values with two different numerical types

```golang
var a int8
var b int32

c := a + b // compile error
```

### Strings

Represented by double quotes `""` or backticks `` ` ``.

It is impossible to change string values by index. You will get compile errors

```golang
var s string = "hello"
s[0] = 'c' // compile error

chars := []byte(s)
chars[0] = 'c'
s2 := string(chars) // no compile error
```

Multiple-line strings can be handled by backticks.

### Errors

Go has one `error` type. There is also a package called `errors` to handle errors.

```golang
err := errors.New("error message")
if err != nil {
  fmt.Println(err)
}
```

### Underlying data structure

Go utilizes blocks of memory to store data.

![picture](https://astaxie.gitbooks.io/build-web-application-with-golang/en/images/2.2.basic.png?raw=true)

### Pro-tip

#### Define by group

If you want to define multiple constants, variables, or imports you can use the group form

```golang
import(
    "fmt"
    "os"
)

const(
    i = 100
    pi = 3.1415
    prefix = "Go_"
)

var(
    i int
    pi float32
    prefix string
)
```

#### iota enumerate

`iota` is used to make `enum`, it begins with `0` and increases by `1`

```golang
const(
    x = iota  // x == 0
    y = iota  // y == 1
    z = iota  // z == 2
    w  // If there is no expression after the constants name, it uses the last expression,
    //so it's saying w = iota implicitly. Therefore w == 3, and y and z both can omit "= iota" as well.
)

const v = iota // once iota meets keyword `const`, it resets to `0`, so v = 0.

const (
  e, f, g = iota, iota, iota // e=0,f=0,g=0 values of iota are same in one line.
)
```

### Arrays

```golang
var arr [n]type

a := [3]int{1,2,3}
b := [10]int{1,2,3}
c := [...]int{1,2,3}
```

`n` is the length of the array, `type` is the type of its elements. Like other languages, we use `[]` to get or set element values within arrays.

Because length is part of the array type, `[3]int` and `[4]int` are different types, so we cannot change the length of arrays. When you use arrays as arguments, functions get their copies instead of references! If you want to use references, use `slice` instead.

Two-dimensional

```golang
doubleArray := [2][4]int{[4]int{1, 2, 3, 4}, [4]int{5, 6, 7, 8}}
easyArray := [2][4]int{{1, 2, 3, 4}, {5, 6, 7, 8}}
```

### Slices

In many situations, the array type is not a good choice - e.g. we don't know the length of the array.

`slice` is not really a `dynamic array`. It's a reference type. `slice` points to an underlying `array` whose declaration is similar to `array`, but doesn't need length.

```golang
var slice []int // exclude length declaration
slice := []byte{'a','b','c'}
```

```golang
// define an array
var array = [10]byte{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}
// define two slices
var aSlice, bSlice []byte

// some convenient operations
aSlice = array[:3] // equals to aSlice = array[0:3] aSlice has elements a,b,c
aSlice = array[5:] // equals to aSlice = array[5:10] aSlice has elements f,g,h,i,j
aSlice = array[:]  // equals to aSlice = array[0:10] aSlice has all elements

// slice from slice
aSlice = array[3:7]  // aSlice has elements d,e,f,g，len=4，cap=7
bSlice = aSlice[1:3] // bSlice contains aSlice[1], aSlice[2], so it has elements e,f
bSlice = aSlice[:3]  // bSlice contains aSlice[0], aSlice[1], aSlice[2], so it has d,e,f
bSlice = aSlice[0:5] // slice could be expanded in range of cap, now bSlice contains d,e,f,g,h
bSlice = aSlice[:]   // bSlice has same elements as aSlice does, which are d,e,f,g
```

Any changes to slice will affect other variables pointing to the same slice or array. For instance, if you change the value of an element in `aSlice`, `bSlice` will be changed as well.

`slice` is like a struct by definition with 3 parts:

1. Pointer that points to where `slice` starts
2. Length of `slice`
3. Capacity, the length from start index to index of `slice`

![picture](https://astaxie.gitbooks.io/build-web-application-with-golang/en/images/2.2.slice2.png?raw=true)

### Maps

```golang
var numbers map[string]int

numbers := make(map[string]int)
numbers["one"] = 1
numbers["two"] = 2

or

numbers := map[string]int {
  "one": 1,
  "two": 2,
}
```

- Map is not ordered. Everytime you print `map` you will get different results. It's impossible to get values by `index` - you have to use `key`
- Map doesn't have a fixed length. It's a reference type just like `slice`. If two maps point to same underlying data, any change will affect both

### Make, new

`make` does memory allocation for built-in models, such as `map`, `slice`, and `channel`, while `new` is for types' memory allocation.

`new(T)` allocates zero-value to type T's memory, returns its memory address, which is the value of type `*T`. By Go's definition, it returns a pointer which points to type T's zero-value.

The built-in function `make(T, args)` has different purposes than `new(T)`. make can be used for slice, map, and channel, and returns a type T with an initial value. The reason for doing this is because the underlying data of these three types must be initialized before they point to them. For example, a slice contains a pointer that points to the underlying array, length and capacity. Before these data are initialized, slice is nil, so for slice, map and channel, make initializes their underlying data and assigns some suitable values.

## Control Statements

### if

```golang
if x := computedValue; x > 10 {
    fmt.Println("x is greater than 10")
} else if x > 20 {
    fmt.Println("x is greater than 20")
} else {
    fmt.Println("x is less than 10")
}
```

### goto

Reroutes the control flow to a previously defined lable within the body of same code block

```golang
func myFunc() {
    i := 0
Here:   // label ends with ":"
    fmt.Println(i)
    i++
    goto Here   // jump to label "Here"
}
```

### for

```golang
for index := 10; index>0; index-- {
    fmt.Println(index)
}

for k,v := range map {
    fmt.Println("map's key:",k)
    fmt.Println("map's val:",v)
}
```

### switch

```golang
switch expr {
case expr1:
    // some instructions
case expr2:
    // some other instructions
    fallthrough
default:
    // other code
}
```

use `fallthrough` to match more cases.

### func

```golang
func SumAndProduct(A, B int) (int, int) {
    return A + B, A * B
}

// variadic functions
func myfunc(arg ...int) {}

// pass memory address
func add1(a *int) int {
    *a = *a + 1 // we changed value of a
    return *a   // return new value of a
}
```

### defer

You can have many `defer` statements in one function; they will execute in reverse order when the program executes to the end of functions. In the case where the program opens some resource files, these files would have to be closed before the function can return with errors

```golang
for i := 0; i < 5; i++ {
    defer fmt.Printf("%d ", i)
}

// prints 4 3 2 1 0
```

## Functions

### Functions as values and types

Functions are also variables in Go, we can use `type` to define them. Functions that have the same signature can be seen as the same type

```golang
// format
type typeName func(input1 inputType1 , input2 inputType2 [, ...]) (result1 resultType1 [, ...])

// example
type testInt func(int) bool // define a function type of variable

func isOdd(integer int) bool {
    return integer%2 != 0
}

func isEven(integer int) bool {
    return integer%2 == 0
}

// pass the function `f` as an argument to another function
func filter(slice []int, f testInt) []int {
    var result []int
    for _, value := range slice {
        if f(value) {
            result = append(result, value)
        }
    }
    return result
}

var slice = []int{1, 2, 3, 4, 5, 7}

func main() {
  odd := filter(slice, isOdd)
  even := filter(slice, isEven)
}
```

### Panic and Recover

Go doesn't have `try-catch` structure like Java does. Instead of throwing exceptions, Go uses `panic` and `recover` to deal with errors.

`Panic` is a built-in function to break the normal flow of programs and get into panic status. When a function calls `panic`, the function will not continue executing but its `defer` functions will continue to execute. The function goes back to the break point which caused the panic status. The program will not terminate until all of these functions return with panic to the first level of that `goroutine`. `panic` can be produced by calling `panic` in the program.

`Recover` is a built-in function to recover `goroutine`'s from panic status. Calling `recover` in `defer` functions is useful because normal functions will not be executed when the program is in the panic status. It catches `panic` values if the program is in the panic status, and it gets `nil` if the program is not in panic status.

```golang
var user = os.Getenv("USER")

func init() {
    defer func() {
        if x := recover(); x != nil {
            fmt.Println("Cannot get user env")
        }
    }()

    if user == "" {
        panic("no value for $USER")
    }
}
```
