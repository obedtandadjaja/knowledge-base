# Golang

Golang is a fast, compiled, garbage-collected, concurrent systems programming language. Golang was created as a future-proof language to meet the challenges of the present and anticipate challenges of the future.

Advantages:
- Compiles large projects within a few seconds
- Open source by nature so defects will be detected and eliminated faster
- Fast since it has simple structure and syntax. It is devoid of classes and type inheritance. The language is based on functions, so it is simple and fast to learn. It’s compiled so it provides faster feedback, shorter time to market, and saves time and money.  It’s simple, so it is more maintainable, and development is faster and cheaper.
- Concurrent in nature with the help of goroutines, channels, and garbage collection
- Cross-platform
- Statically typed so developers have to be more accurate and attentive, so the code is neater and safer

Disadvantages:
- Less flexible copared to other dynamically typed languages
- Lack of 3rd party modules
- Differs a lot from C-based languages
- Has no generics (generics allow writing code which can be reusable - it saves time and effort in some cases)

# Table of Contents

  * [Commands](#commands)
    + [go build](#go-build)
    + [go clean](#go-clean)
    + [go fmt](#go-fmt)
    + [go get](#go-get)
    + [go install](#go-install)
    + [go test](#go-test)
    + [go fix](#go-fix)
    + [go list](#go-list)
    + [go run](#go-run)
  * [Basic Knowledge](#basic-knowledge)
  * [Naming Convention](#naming-convention)
  * [Foundation](#foundation)
    + [Define variables](#define-variables)
    + [Constants](#constants)
    + [Numerical types](#numerical-types)
    + [Pointers](#pointers)
    + [Strings](#strings)
    + [Errors](#errors)
    + [Underlying data structure](#underlying-data-structure)
    + [Pro-tip](#pro-tip)
      - [Define by group](#define-by-group)
      - [iota enumerate](#iota-enumerate)
    + [Arrays](#arrays)
    + [Slices](#slices)
    + [Maps](#maps)
    + [Make, new](#make--new)
  * [Control Statements](#control-statements)
    + [if](#if)
    + [goto](#goto)
    + [for](#for)
    + [switch](#switch)
    + [func](#func)
    + [defer](#defer)
  * [Functions](#functions)
    + [Functions as values and types](#functions-as-values-and-types)
    + [Panic and Recover](#panic-and-recover)
  * [Struct](#struct)
    + [Embedded fields in struct](#embedded-fields-in-struct)
  * [Inheritance](#inheritance)
    + [Method inheritance](#method-inheritance)
    + [Method overriding](#method-overriding)
  * [Interface](#interface)
    + [Empty interface](#empty-interface)
    + [Interface check](#interface-check)
    + [Embedded interfaces](#embedded-interfaces)
  * [Concurrency](#concurrency)
    + [goroutine](#goroutine)
    + [channels](#channels)
    + [Buffered channels](#buffered-channels)
    + [Range and Close](#range-and-close)
    + [Select](#select)
    + [Timeout](#timeout)

## Commands

### go build

- Compiles packages and dependencies
- Go build ignores files whose names start with `_` or `.`
- By default the executable will be generated in the same folder. If you want the file to be generated in `$GOPATH/bin` then use `go install` instead
- `go build` will compile all the files in the folder, if you just want to compile one file then use `go build <file_path>`

### go clean

- Cleans files that are generated by compilers
- Do this before pushing a commit to Github

### go fmt

- Enforces go code formatting to the project. It will rewrite the source files after formatting code

### go get

- Fetches remote packages. Currently only supports BitBucket, Github, Google Code, and Launchpad
- Does the following actions: downloads the source code, then executes `go install`

### go install

- Compiles all packages and generates files, then moves them to `$GOPATH/pkg` or `$GOPATH/bin`

### go test

- Loads all files whose name include `*_test.go` and generates test files, then prints information about the test results
- Tests all your test files by default

### go fix

- Upgrades from an older version to newer version of golang

### go list

- Lists all installed packages

### go run

- Compiles temporary files and run the application

## Basic Knowledge

25 keywords:
```
break    default      func    interface    select
case     defer        go      map          struct
chan     else         goto    package      switch
const    fallthrough  if      range        type
continue for          import  return       var
```

Go programs are composed by `package`. `package main` tells us that this package will be compiled to a program instead of package files whose extensions are `.a`.

Every executable program has one and only one `main` package, and you need an entry function called `main` without any arguments or return values in the `main` package.

The way to think about packages in Go is `modularity` (break up program into many modules) and `reusability` (every module can be reused by many programs).

Each go file is in some package, and that package should be a distinct folder in the GOPATH, but main is a special package which doesn't require a `main` folder. 

Conclusion: Go uses `package` (like modules in Python) to organize programs. The function `main.main()` is the entry point of any program. Go standardizes language and most of the programming methodology (gofmt).

## Naming Convention

- Any variable that beings with a capital letter means it will be exported, private otherwise.
- The same rule applies for functions and constants, no `public` or `private` keyword exists in Go.

## Foundation

### Define variables

The keyword `var` is the basic form to define variables, notice that Go puts the variable type `after` the name.

```golang
var variableName type
var var1, var2, var3 type
var myName string = "Obed"
var sibling1, sibling2 string = "Abel", "Olivia"
var sibling1, sibling2 = "Abel", "Olivia"
```

We can also use `:=` to replace `var` and `type` combination, this is called a `short assignment`. It has one limitation: it can only be used inside of a function. You will get compile error when it is called outside of function block. Therefore, `var` is used to define global variables

```golang
myName := "Obed"
```

`_` (blank) is a special variable name. Any value that is given to it will be ignored

```golang
_, b := 34, 35
```

### Constants

Values that are determined during compile time and cannot be changed during runtime. In Go, you can use number, boolean, enum, or string as constant types

```golang
const str = "a string"
const str string = "a string"

const bool = true
const num = 1000
const pi = 3.14
```

### Numerical types

```
rune   int8   int16   int32   int64
byte   uint8  uint16  uint32  uint64
float32  float64
```

`rune` is alias of `int32` and `byte` is alias of `uint8`.

You cannot assign values with two different numerical types

```golang
var a int8
var b int32

c := a + b // compile error
```

### Pointers

```
func main() {
	i, j := 42, 2701

	p := &i         // point to i
	fmt.Println(*p) // read i through the pointer
	*p = 21         // set i through the pointer
	fmt.Println(i)  // see the new value of i

	p = &j         // point to j
	*p = *p / 37   // divide j through the pointer
	fmt.Println(*p) // see the new value of j
}
```

### Strings

Represented by double quotes `""` or backticks `` ` ``.

It is impossible to change string values by index. You will get compile errors

```golang
var s string = "hello"
s[0] = 'c' // compile error

chars := []byte(s)
chars[0] = 'c'
s2 := string(chars) // no compile error
```

Multiple-line strings can be handled by backticks.

### Errors

Go has one `error` type. There is also a package called `errors` to handle errors.

```golang
err := errors.New("error message")
if err != nil {
  fmt.Println(err)
}
```

### Underlying data structure

Go utilizes blocks of memory to store data.

![picture](https://astaxie.gitbooks.io/build-web-application-with-golang/en/images/2.2.basic.png?raw=true)

### Pro-tip

#### Define by group

If you want to define multiple constants, variables, or imports you can use the group form

```golang
import(
    "fmt"
    "os"
)

const(
    i = 100
    pi = 3.1415
    prefix = "Go_"
)

var(
    i int
    pi float32
    prefix string
)
```

#### iota enumerate

`iota` is used to make `enum`, it begins with `0` and increases by `1`

```golang
const(
    x = iota  // x == 0
    y = iota  // y == 1
    z = iota  // z == 2
    w  // If there is no expression after the constants name, it uses the last expression,
    //so it's saying w = iota implicitly. Therefore w == 3, and y and z both can omit "= iota" as well.
)

const v = iota // once iota meets keyword `const`, it resets to `0`, so v = 0.

const (
  e, f, g = iota, iota, iota // e=0,f=0,g=0 values of iota are same in one line.
)
```

### Arrays

```golang
var arr [n]type

a := [3]int{1,2,3}
b := [10]int{1,2,3}
c := [...]int{1,2,3}
```

`n` is the length of the array, `type` is the type of its elements. Like other languages, we use `[]` to get or set element values within arrays.

Because length is part of the array type, `[3]int` and `[4]int` are different types, so we cannot change the length of arrays. When you use arrays as arguments, functions get their copies instead of references! If you want to use references, use `slice` instead.

Two-dimensional

```golang
doubleArray := [2][4]int{[4]int{1, 2, 3, 4}, [4]int{5, 6, 7, 8}}
easyArray := [2][4]int{{1, 2, 3, 4}, {5, 6, 7, 8}}
```

### Slices

In many situations, the array type is not a good choice - e.g. we don't know the length of the array.

`slice` is not really a `dynamic array`. It's a reference type. `slice` points to an underlying `array` whose declaration is similar to `array`, but doesn't need length.

```golang
var slice []int // exclude length declaration
slice := []byte{'a','b','c'}
```

```golang
// define an array
var array = [10]byte{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}
// define two slices
var aSlice, bSlice []byte

// some convenient operations
aSlice = array[:3] // equals to aSlice = array[0:3] aSlice has elements a,b,c
aSlice = array[5:] // equals to aSlice = array[5:10] aSlice has elements f,g,h,i,j
aSlice = array[:]  // equals to aSlice = array[0:10] aSlice has all elements

// slice from slice
aSlice = array[3:7]  // aSlice has elements d,e,f,g，len=4，cap=7
bSlice = aSlice[1:3] // bSlice contains aSlice[1], aSlice[2], so it has elements e,f
bSlice = aSlice[:3]  // bSlice contains aSlice[0], aSlice[1], aSlice[2], so it has d,e,f
bSlice = aSlice[0:5] // slice could be expanded in range of cap, now bSlice contains d,e,f,g,h
bSlice = aSlice[:]   // bSlice has same elements as aSlice does, which are d,e,f,g
```

Any changes to slice will affect other variables pointing to the same slice or array. For instance, if you change the value of an element in `aSlice`, `bSlice` will be changed as well.

`slice` is like a struct by definition with 3 parts:

1. Pointer that points to where `slice` starts
2. Length of `slice`
3. Capacity, the length from start index to index of `slice`

![picture](https://astaxie.gitbooks.io/build-web-application-with-golang/en/images/2.2.slice2.png?raw=true)

### Maps

```golang
var numbers map[string]int

numbers := make(map[string]int)
numbers["one"] = 1
numbers["two"] = 2

or

numbers := map[string]int {
  "one": 1,
  "two": 2,
}
```

- Map is not ordered. Everytime you print `map` you will get different results. It's impossible to get values by `index` - you have to use `key`
- Map doesn't have a fixed length. It's a reference type just like `slice`. If two maps point to same underlying data, any change will affect both

### Make, new

`make` does memory allocation for built-in models, such as `map`, `slice`, and `channel`, while `new` is for types' memory allocation.

`new(T)` allocates zero-value to type T's memory, returns its memory address, which is the value of type `*T`. By Go's definition, it returns a pointer which points to type T's zero-value.

The built-in function `make(T, args)` has different purposes than `new(T)`. make can be used for slice, map, and channel, and returns a type T with an initial value. The reason for doing this is because the underlying data of these three types must be initialized before they point to them. For example, a slice contains a pointer that points to the underlying array, length and capacity. Before these data are initialized, slice is nil, so for slice, map and channel, make initializes their underlying data and assigns some suitable values.

## Control Statements

### if

```golang
if x := computedValue; x > 10 {
    fmt.Println("x is greater than 10")
} else if x > 20 {
    fmt.Println("x is greater than 20")
} else {
    fmt.Println("x is less than 10")
}
```

### goto

Reroutes the control flow to a previously defined lable within the body of same code block

```golang
func myFunc() {
    i := 0
Here:   // label ends with ":"
    fmt.Println(i)
    i++
    goto Here   // jump to label "Here"
}
```

### for

```golang
for index := 10; index>0; index-- {
    fmt.Println(index)
}

for k,v := range map {
    fmt.Println("map's key:",k)
    fmt.Println("map's val:",v)
}
```

### switch

```golang
switch expr {
case expr1:
    // some instructions
case expr2:
    // some other instructions
    fallthrough
default:
    // other code
}
```

use `fallthrough` to match more cases.

### func

```golang
func SumAndProduct(A, B int) (int, int) {
    return A + B, A * B
}

// variadic functions
func myfunc(arg ...int) {}

// pass memory address
func add1(a *int) int {
    *a = *a + 1 // we changed value of a
    return *a   // return new value of a
}
```

### defer

You can have many `defer` statements in one function; they will execute in reverse order when the program executes to the end of functions. In the case where the program opens some resource files, these files would have to be closed before the function can return with errors

```golang
for i := 0; i < 5; i++ {
    defer fmt.Printf("%d ", i)
}

// prints 4 3 2 1 0
```

## Functions

### Functions as values and types

Functions are also variables in Go, we can use `type` to define them. Functions that have the same signature can be seen as the same type

```golang
// format
type typeName func(input1 inputType1 , input2 inputType2 [, ...]) (result1 resultType1 [, ...])

// example
type testInt func(int) bool // define a function type of variable

func isOdd(integer int) bool {
    return integer%2 != 0
}

func isEven(integer int) bool {
    return integer%2 == 0
}

// pass the function `f` as an argument to another function
func filter(slice []int, f testInt) []int {
    var result []int
    for _, value := range slice {
        if f(value) {
            result = append(result, value)
        }
    }
    return result
}

var slice = []int{1, 2, 3, 4, 5, 7}

func main() {
  odd := filter(slice, isOdd)
  even := filter(slice, isEven)
}
```

### Panic and Recover

Go doesn't have `try-catch` structure like Java does. Instead of throwing exceptions, Go uses `panic` and `recover` to deal with errors.

`Panic` is a built-in function to break the normal flow of programs and get into panic status. When a function calls `panic`, the function will not continue executing but its `defer` functions will continue to execute. The function goes back to the break point which caused the panic status. The program will not terminate until all of these functions return with panic to the first level of that `goroutine`. `panic` can be produced by calling `panic` in the program.

`Recover` is a built-in function to recover `goroutine`'s from panic status. Calling `recover` in `defer` functions is useful because normal functions will not be executed when the program is in the panic status. It catches `panic` values if the program is in the panic status, and it gets `nil` if the program is not in panic status.

```golang
var user = os.Getenv("USER")

func init() {
    defer func() {
        if x := recover(); x != nil {
            fmt.Println("Cannot get user env")
        }
    }()

    if user == "" {
        panic("no value for $USER")
    }
}
```

## Struct

```golang
type person struct {
    name string
    age int
}

var P person  // p is person type

P.name = "Astaxie" 
P.age = 25
fmt.Printf("The person's name is %s\n", P.name)

// other ways to initialize
P := person{"Tom", 25} // by order
P := person{age:24, name:"Bob"} // by attributes
P := struct{name string; age int}{"Amy",18} // by anonymous struct
```

### Embedded fields in struct

```golang
type Human struct {
    name   string
    age    int
    weight int
}

type Student struct {
    Human     // embedded field, it means Student struct includes all fields that Human has.
    specialty string
}

func main() {
    // instantiate and initialize a student
    mark := Student{Human{"Mark", 25, 120}, "Computer Science"}
    
    // access fields
    fmt.Println("His name is ", mark.name)
    fmt.Println("His age is ", mark.age)
    fmt.Println("His weight is ", mark.weight)
    fmt.Println("His specialty is ", mark.specialty)
}
```

## Inheritance

### Method inheritance

```golang
type Human struct {
    name  string
    age   int
    phone string
}

type Student struct {
    Human  // anonymous field
    school string
}

// define a method in Human
func (h *Human) SayHi() {
    fmt.Printf("Hi, I am %s you can call me on %s\n", h.name, h.phone)
}

func main() {
    mark := Student{Human{"Mark", 25, "222-222-YYYY"}, "MIT"}
    mark.SayHi()
}
```

### Method overriding

```golang
type Human struct {
    name  string
    age   int
    phone string
}

type Employee struct {
    Human
    company string
}

func (h *Human) SayHi() {
    fmt.Printf("Hi, I am %s you can call me on %s\n", h.name, h.phone)
}

func (e *Employee) SayHi() {
    fmt.Printf("Hi, I am %s, I work at %s. Call me on %s\n", e.name,
        e.company, e.phone) //Yes you can split into 2 lines here.
}

func main() {
    sam := Employee{Human{"Sam", 45, "111-888-XXXX"}, "Golang Inc"}
    sam.SayHi()
}
```

## Interface

```golang
type Men interface {
    SayHi()
    Sing(lyrics string)
    BorrowMoney(amount float32)
}
```

A type matches an interface when it fulfills all the required methods in the interface.

### Empty interface

If a function uses an empty interface as its argument type, it can accept any type; if a function uses empty interface as its return value type, it can return any type.

```golang
var empty interface{}

empty = 5
empty = "hello"
```

### Interface check

```golang
value, ok := element.(Interface)
```

### Embedded interfaces

```golang
type Interface interface {
    sort.Interface // embedded sort.Interface
    Push(x interface{}) //a Push method to push elements into the heap
    Pop() interface{} //a Pop method that pops elements from the heap
}

// sort.Interface
type Interface interface {
    // Len is the number of elements in the collection.
    Len() int
    // Less returns whether the element with index i should sort
    // before the element with index j.
    Less(i, j int) bool
    // Swap swaps the elements with indexes i and j.
    Swap(i, j int)
}
```

## Concurrency

### goroutine

Goroutines and concurrency are built into the core design of Go. They're similar to threads but work differently. 

- Full support to sharing memory among goroutines
- Typically around 4-5 KB of stack memory compared to 1 MB of threads. Easy to run thousands of goroutines on a single computer
- More lightweight, more efficient and more convenient than system threads

Goroutines run on the thread manager at runtime in Go. We use the `go` keyword to create new goroutine

```golang
func say(s string) {
    for i := 0; i < 5; i++ {
        runtime.Gosched()
        fmt.Println(s)
    }
}

func main() {
    go say("world") // create a new goroutine
    say("hello")    // current goroutine
}

// result
    hello
    world
    hello
    world
    hello
    world
    ...
```

The two goroutines share some memory, but we would be better off following the design recipe: Don't use shared data to communicate, use communication to share data.

In Go 1.5,the runtime now sets the default number of threads to run simultaneously, defined by GOMAXPROCS, to the number of cores available on the CPU

Before Go 1.5,The scheduler only uses one thread to run all goroutines, which means it only implements concurrency. If you want to use more CPU cores in order to take advantage of parallel processing, you have to call runtime.GOMAXPROCS(n) to set the number of cores you want to use. If n<1, it changes nothing

### channels

goroutines run in the same memory address space, so you have to maintain synchronization when you want to access shared memory. Use `channel` to communicate between goroutines. 

It is like two-way pipeline in Unix shells: use `channel` to send or receive data. They only data type that can be used in channels is the type `channel` and the keyword `chan`. Be aware that you have to use `make` to create a new `channel`

```golang
ci := make(chan int)
cs := make(chan string)
cf := make(chan interface{})
```

channel uses the operator `<-` to send or receive data

```golang
ch <- v     // send v to channel ch
v := <- ch  // receive data from ch, and assign to v
```

```golang
func sum(a []int, c chan int) {
    total := 0
    for _, v := range a {
        total += v
    }
    c <- total // send total to c
}

func main() {
    a := []int{7, 2, 8, -9, 4, 0}

    c := make(chan int)
    go sum(a[:len(a)/2], c)
    go sum(a[len(a)/2:], c)
    x, y := <-c, <-c // receive from c

    fmt.Println(x, y, x+y)
}
```

Sending and receiving data in channels blocks operation by default, so it's much easier to use synchronous goroutines. It will not continue when still receiving data from an empty channel until other goroutines send data to this channel. On the other hand, the goroutine will not continue until the data it sends to a channel is received.

### Buffered channels

Go also has buffered channels that can store more than a single element. For example, `ch := make(chan bool, 4)`, here we create a channel that can store 4 boolean elements. So in this channel, we are able to send 4 elements into it without blocking, but the goroutine will be blocked when you try to send a fifth element and no goroutine receives it.

### Range and Close

```golang
func fibonacci(n int, c chan int) {
    x, y := 1, 1
    for i := 0; i < n; i++ {
        c <- x
        x, y = y, x+y
    }
    close(c)
}

func main() {
    c := make(chan int, 10)
    go fibonacci(cap(c), c)
    for i := range c {
        fmt.Println(i)
    }
}
```

`for i := range c` will not stop reading data from channel until the channel is closed. We use the keyword `close` to close the channel in above example

Remember to always close channels in producers and not in consumers, or it's very easy to get into panic status.

Another thing you need to remember is that channels are not like files. You don't have to close them frequently unless you are sure the channel is completely useless, or you want to exit range loops.

### Select

In the above examples, we only use on channel, but how can we deal with more than one channel? Go has a keyword called `select` to listen to many channels.

`select` is blocking by default and it continues to execute only when one of channels has data to send or receive. If several channels are ready to use at the same time, select chooses which to execute randomly

```golang
func fibonacci(c, quit chan int) {
    x, y := 1, 1
    for {
        select {
        case c <- x:
            x, y = y, x+y
        case <-quit:
            fmt.Println("quit")
            return
        }
    }
}

func main() {
    c := make(chan int)
    quit := make(chan int)
    go func() {
        for i := 0; i < 10; i++ {
            fmt.Println(<-c)
        }
        quit <- 0
    }()
    fibonacci(c, quit)
}
```

### Timeout

Sometimes a goroutine becomes blocked. How can we avoid this to prevent the whole program from blocking? We can set a timeout in the select

```golang
func main() {
    c := make(chan int)
    o := make(chan bool)
    go func() {
        for {
            select {
            case v := <-c:
                println(v)
            case <-time.After(5 * time.Second):
                println("timeout")
                o <- true
                break
            }
        }
    }()
    <-o
}
```
